import os
from collections import Counter
from typing import List, Tuple
from typing import Counter as CounterType


def generate_data(input_file:str) -> List[str]:
    """
    Generate list of data from input file
    :param input_file: (str) input file to parse
    :return: (List[str]) a list containing the values from the input file
    """
    # Initialize list of data to return
    data = []

    # For each line item, clean it and append to list
    with open(os.path.abspath(input_file), 'r') as f_in:
        for i in f_in:
            data.append(i.strip())

    # return list
    return data


def generate_counter(data: List[str]) -> CounterType:
    """
    Counter how many strings in a list have various n-plicates. E.g.

        abba - has duplicates, but no triplicates
        abbb - has no duplicates, but it has a triplicate

    :param data: (List[str]) list of strings to check
    :return: (Counter) a counter containing the number of words containing n-plicates:

    The List:

        ['abcdef',  # All single letters
         'bababc',  # A single letter, a duplicate, and a triplicate
         'abbcde',  # Single letters, a duplicate
         'abcccd',  # Single letters, a triplicate
         'aabcdd',  # Single letters, duplicates
         'abcdee',  # Single letters, duplicate
         'ababab']  # Triplicates

    Returns:

        Counter({
            '1': 6,
            '2': 4,
            '3': 3
        })
    """
    # Initialize counter of n-plicates. This is what's returned.
    res = Counter()

    # Process each line of data input
    for i in data:
        # Initialize counter that counts the letters in str
        c = Counter(i)

        # We only care about whether or not a str contains n-plicates of a str, not,
        # not how many n-plicates it has.
        # Take the number of occurences of each letter in a str and initialize a set
        # of those
        _values = set(c.values())

        # Loop through the set and add the values to the results
        for val in _values:
            # Updating the result will increment the value in the counter
            res.update(str(val))

    # Return results
    return res


def generate_checksum(counter: CounterType, multiples:Tuple[int] = (2, 3)) -> \
        int:
    """
    Generate the a simplistic checksum using a specified tuple of n-plicates. This
    checksum is generated by multiplying the number of words containing the specified
    n-plicates.

    For the day02a challenge we have to generate the checksum by using the duplicates
    and triplicates.

    :param counter: (Counter) a counter containing a number of n-plicates
    :param multiples: (tuple) the n-plicates to use for generating the checksum, e.g.
    use duplicates and triplicates by default (2, 3)
    :return: (int) the resulting checksum
    """
    # Initialize the checksum by setting it to 1
    checksum = 1

    # For each n-plicate, multiply by existing checksum
    for i in multiples:
        checksum *= counter[str(i)]

    # Return resulting checksum
    return checksum


def day02a(input_file:str) -> str:
    """
    Solver for day 2, part a of Advent of Code 2018.
    :param input_file: (str) File of the AoC inputs, a set of strings to parse
    :return: (str) The checksum requested
    """
    # TODO: Return only checksum
    # Get data into a list
    data = generate_data(input_file)

    # Generate the counter of the number of n-plicates
    c = generate_counter(data)

    # Generate checksum
    checksum = generate_checksum(c)

    # Return text identifying checksum
    return f'Checksum is {checksum}.'


def count_string_differences(str1: str, str2: str) -> int:
    """
    Compare two strings and indentify the number of differences between them. E.g.:

        abcdefg, abcdefg -> 0
        abcdefg, abcdeff -> 1
        abcdefg, accdeff -> 2
        abcdefg, abc -> -1

    :param str1: (str) the first string to look at
    :param str2: (str) the second string to look at
    :return: (int) the number of differences between the two strings
    """
    # TODO: Make this work with a list (set?) of strings, instead of two single strings
    # If strings are equal, return no differences
    if str1 == str2:
        return 0

    # If strings are not the same length, fail
    # TODO: implement exception here, instead of returning -1
    if len(str1) != len(str2):
        return -1

    # Count total non-matching characters
    c = 0
    # For each difference in one string, compare to same character location in the other
    for idx, val in enumerate(str1):
        if str2[idx] != val:
            c += 1

    # Return total number of differences
    return c


def generate_matches(data: List[str]) -> List[Tuple[str, str]]:
    """
    Get the the strings in a list that are different by one character.
    :param data: (List[str]) a list of matching strings
    :return: (List[Tuple[str, str]]) A list containing
    """
    # TODO: allow specifying closeness of match
    # Initialize list of matching strings
    matches = []

    # Loop through data. We need index to save time and not duplicate searches
    for idx, val in enumerate(data):

        # Check all remaining strings to see how close the match is
        for num in range(idx + 1, len(data)):

            # Check strength of match. If only a single difference, append to matches
            if count_string_differences(val, data[num]) == 1:

                # Append a pair of matches to the list
                matches.append((val, data[num]))

    # Return resulting tuple of matches
    return matches


def identify_matched_letters(data: List[Tuple[str, str]]) -> List[str]:
    """
    Take a list of tuples with matched strings and identify the letters that match
    between each pair of strings.
    :param data: (List[Tuple[str, str]]) A list of matching string pairs.
    :return: (List[str]) A list of matching letters in the strings.
    """
    # TODO: Pair the string pair with the matched letters.
    # Initialize match list
    matches = []

    # Compare each string pair in the list
    for _tuple in data:
        # Initialize match
        match = []

        # For cleaner code, use str1, str2 vs _tuple[0], _tuple[1]
        str1 = _tuple[0]
        str2 = _tuple[1]

        # For each letter in str1, compare to same position in str2
        for idx, val in enumerate(str1):
            # If the characters match, append to the match
            if str2[idx] == val:
                match.append(val)

        # Add the match to the overall match list
        matches.append(''.join(match))

    # Return the list of matches
    return matches


def day02b(input_file: str) -> str:
    """
    Solver for day 2, part b of Advent of Code 2018. This requires a string of matching characters
    from two strings that only differ by one character.
    :param input_file: (str) file location of AoC input data
    :return: a string containing the requested matching characters
    """
    # Generate list from input data
    data = generate_data(input_file)

    # Generate list of matching words
    matches = generate_matches(data)

    # Generate matched letters within the matches
    matching_letters = identify_matched_letters(matches)

    # Make sure only a single match
    if len(matching_letters) == 1:
        return matching_letters.pop()

    # If too many matches, return False and report the problem
    # TODO: Turn this into exception
    return f'Too many matches: {matches}'